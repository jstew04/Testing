<!DOCTYPE html>
<html>
<head>
  <title>Space Invaders Ultra Deluxe</title>
  <style>
    body { background: radial-gradient(circle, #050010, #000000); margin: 0; overflow: hidden; }
    canvas { background: transparent; display: block; margin: auto; border: 3px solid #6df; box-shadow: 0 0 25px #6df; }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
"use strict";

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// Game states
const STATE_MENU = "menu";
const STATE_PLAYING = "playing";
const STATE_PAUSED = "paused";
const STATE_GAMEOVER = "gameover";
const STATE_SETTINGS = "settings";

let gameState = STATE_MENU;

// Core game variables
let score = 0;
let highScore = 0;
let lives = 3;
let level = 1;

// Entities
let player = {
  x: WIDTH / 2 - 20,
  y: HEIGHT - 70,
  width: 40,
  height: 40,
  speed: 6,
  rapid: false,
  shield: false,
  rapidUntil: 0,
  shieldUntil: 0
};

// bullets: {x,y,width,height,vy,vx,fromPlayer,dead}
let bullets = [];
let enemies = [];
let boss = null;     // {x,y,width,height,hp,maxHp,vx,alive,direction}
let bossTelegraph = null; // {pattern, fireTime}
let powerups = [];
let particles = [];
let stars = [];

let enemyDirection = 1;
let enemySpeed = 0.6;

const ENEMY_STYLES = [
  { bodyStart: "#ff66cc", bodyEnd: "#ff2e9f", eye: "#17021e", accent: "#ffd3f7" },
  { bodyStart: "#66ffb2", bodyEnd: "#20d07e", eye: "#013b25", accent: "#d9ffe9" },
  { bodyStart: "#66a6ff", bodyEnd: "#1d64ff", eye: "#001733", accent: "#d7e9ff" },
  { bodyStart: "#ffd966", bodyEnd: "#ff9f1d", eye: "#3b1a00", accent: "#fff2ba" }
];

let nextShotTime = 0;
let nextBossShotTime = 0;
let nextEnemyShotTime = 0;

// Input
let input = {
  left: false,
  right: false,
  shoot: false
};

// Touch controls
const touchControls = {
  left: { x: 20, y: HEIGHT - 80, width: 80, height: 60 },
  right: { x: 120, y: HEIGHT - 80, width: 80, height: 60 },
  shoot: { x: WIDTH - 100, y: HEIGHT - 80, width: 80, height: 60 }
};

// Audio
let audioCtx = null;
let musicEnabled = true;
let sfxEnabled = true;
let musicInterval = null;
let audioInitialized = false;

// Utility helpers
function rectsIntersect(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function pointInRect(pos, rect) {
  return (
    pos.x >= rect.x &&
    pos.x <= rect.x + rect.width &&
    pos.y >= rect.y &&
    pos.y <= rect.y + rect.height
  );
}

function getPointerPos(e) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (canvas.width / rect.width),
    y: (e.clientY - rect.top) * (canvas.height / rect.height)
  };
}

// Starfield background
function initStars() {
  stars = [];
  const count = 120;
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * WIDTH,
      y: Math.random() * HEIGHT,
      speed: 0.5 + Math.random() * 1.5,
      size: 0.5 + Math.random() * 2
    });
  }
}

function updateStars() {
  for (let s of stars) {
    s.y += s.speed;
    if (s.y > HEIGHT) {
      s.y = -5;
      s.x = Math.random() * WIDTH;
      s.speed = 0.5 + Math.random() * 1.5;
      s.size = 0.5 + Math.random() * 2;
    }
  }
}

function drawStars() {
  ctx.save();
  for (let s of stars) {
    const alpha = 0.4 + (s.speed / 3);
    ctx.globalAlpha = Math.min(1, alpha);
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

// Audio (simple Web Audio retro bleeps)
function initAudio() {
  if (audioCtx) return;
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (!Ctx) return;
    audioCtx = new Ctx();
  } catch (e) {
    audioCtx = null;
  }
}

function playBeep(freq, duration, type, volume) {
  if (!audioCtx || !sfxEnabled) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type || "square";
  osc.frequency.value = freq;
  gain.gain.value = volume || 0.12;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  osc.start(now);
  osc.stop(now + duration);
}

function playShoot() {
  playBeep(800, 0.06, "square", 0.15);
}

function playEnemyShoot() {
  playBeep(300, 0.1, "square", 0.09);
}

function playBossShoot() {
  playBeep(520, 0.12, "sawtooth", 0.11);
}

function playExplosion() {
  playBeep(180, 0.2, "square", 0.25);
}

function playHit() {
  playBeep(400, 0.12, "sawtooth", 0.2);
}

function startMusic() {
  if (!audioCtx || !musicEnabled) return;
  if (musicInterval) return;
  const pattern = [440, 660, 550, 880];
  let index = 0;
  musicInterval = setInterval(function() {
    if (!musicEnabled) return;
    playBeep(pattern[index % pattern.length], 0.15, "triangle", 0.06);
    index++;
  }, 320);
}

function stopMusic() {
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
}

function toggleMusic() {
  musicEnabled = !musicEnabled;
  if (musicEnabled && audioInitialized && audioCtx) {
    startMusic();
  } else {
    stopMusic();
  }
}

function toggleSfx() {
  sfxEnabled = !sfxEnabled;
}

function handleFirstInteraction() {
  if (!audioInitialized) {
    initAudio();
    audioInitialized = true;
    if (musicEnabled && audioCtx) {
      startMusic();
    }
  }
}

// High score persistence
function loadHighScore() {
  try {
    const saved = localStorage.getItem("si_highscore");
    if (saved) {
      highScore = parseInt(saved, 10) || 0;
    }
  } catch (e) {
    highScore = 0;
  }
}

function saveHighScore() {
  try {
    localStorage.setItem("si_highscore", String(highScore));
  } catch (e) {}
}

function updateHighScore() {
  if (score > highScore) {
    highScore = score;
    saveHighScore();
  }
}

// Particles (explosions)
function spawnExplosion(x, y, count) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x: x,
      y: y,
      vx: (Math.random() * 2 - 1) * 4,
      vy: (Math.random() * 2 - 1) * 4,
      life: 400 + Math.random() * 400
    });
  }
}

function updateParticles() {
  for (let p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 16;
  }
  particles = particles.filter(p => p.life > 0);
}

function drawParticles() {
  ctx.save();
  for (let p of particles) {
    const alpha = Math.max(0, Math.min(1, p.life / 800));
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#ffcc66";
    ctx.fillRect(p.x, p.y, 3, 3);
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

// Power-ups (including life drops)
function dropPowerup(x, y) {
  if (Math.random() < 0.25) {
    const types = ["shield", "rapid", "nuke", "life"];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push({
      x: x - 10,
      y: y,
      width: 20,
      height: 20,
      type: type,
      collected: false
    });
  }
}

function applyPowerup(type) {
  const now = Date.now();
  if (type === "shield") {
    player.shield = true;
    player.shieldUntil = now + 10000;
  } else if (type === "rapid") {
    player.rapid = true;
    player.rapidUntil = now + 8000;
  } else if (type === "nuke") {
    for (let enemy of enemies) {
      enemy.alive = false;
    }
    if (boss && boss.alive) {
      boss.hp -= 50;
      if (boss.hp <= 0) {
        boss.alive = false;
        score += 1000;
      }
    }
    spawnExplosion(player.x + player.width / 2, player.y - 40, 40);
  } else if (type === "life") {
    lives = Math.min(lives + 1, 6);
    playHit();
  }
}

// Movement
function movePlayer() {
  if (input.left && !input.right) {
    player.x -= player.speed;
  } else if (input.right && !input.left) {
    player.x += player.speed;
  }
  if (player.x < 10) player.x = 10;
  if (player.x + player.width > WIDTH - 10) player.x = WIDTH - 10 - player.width;
}

function moveBullets() {
  const now = Date.now();
  for (let b of bullets) {
    if (b.gravity) {
      b.vy += b.gravity;
    }
    if (b.vx) b.x += b.vx;
    b.y += b.vy;
    if (b.spin) {
      b.rotation = (b.rotation || 0) + b.spin;
    }
    if (!b.fromPlayer) {
      if (b.type === "grenade" && b.explodeTime && now >= b.explodeTime) {
        detonateGrenade(b);
      } else if (b.type === "bomb" && (b.y + b.height >= player.y + 6 || b.vy > 6.5)) {
        detonateBomb(b);
      }
    }
  }
  bullets = bullets.filter(b => !b.dead && b.y > -30 && b.y < HEIGHT + 30 && b.x > -30 && b.x < WIDTH + 30);
}

function moveEnemies() {
  if (!enemies.length) return;
  let hitEdge = false;
  for (let enemy of enemies) {
    if (!enemy.alive) continue;
    enemy.x += enemyDirection * enemySpeed;
    if (enemy.x < 20 || enemy.x + enemy.width > WIDTH - 20) {
      hitEdge = true;
    }
  }
  if (hitEdge) {
    enemyDirection *= -1;
    for (let enemy of enemies) {
      enemy.y += 12;
    }
  }
}

function moveBoss() {
  if (!boss || !boss.alive) return;
  boss.x += boss.vx * boss.direction;
  if (boss.x < 40 || boss.x + boss.width > WIDTH - 40) {
    boss.direction *= -1;
  }
  boss.y += 0.05;
}

function movePowerups() {
  for (let p of powerups) {
    p.y += 2;
  }
  powerups = powerups.filter(p => !p.collected && p.y < HEIGHT + 40);
}

// Shooting
function tryShoot(now) {
  if (now < nextShotTime) return;
  const delay = player.rapid ? 80 : 220;
  nextShotTime = now + delay;
  const bullet = {
    x: player.x + player.width / 2 - 2,
    y: player.y,
    width: 4,
    height: 12,
    vy: player.rapid ? -14 : -9,
    vx: 0,
    fromPlayer: true,
    dead: false
  };
  bullets.push(bullet);
  playShoot();
}

function enemyTryShoot(now) {
  if (!enemies.length) return;
  if (now < nextEnemyShotTime) return;

  const baseDelay = 900;
  const minDelay = 500;
  const delay = Math.max(minDelay, baseDelay + Math.random() * 300 - level * 40);
  nextEnemyShotTime = now + delay;

  const shooters = enemies.filter(e => e.alive);
  if (!shooters.length) return;

  const shooter = shooters[Math.floor(Math.random() * shooters.length)];
  const bullet = {
    x: shooter.x + shooter.width / 2 - 2,
    y: shooter.y + shooter.height,
    width: 4,
    height: 10,
    vy: 2.5 + level * 0.15,
    vx: 0,
    fromPlayer: false,
    dead: false
  };
  bullets.push(bullet);
  playEnemyShoot();
}

function spawnBossBullet(x, y, vx, vy, options) {
  const bullet = {
    x: x,
    y: y,
    width: (options && options.width) || 4,
    height: (options && options.height) || 12,
    vy: vy,
    vx: vx || 0,
    fromPlayer: false,
    dead: false,
    type: (options && options.type) || "standard"
  };
  if (options) {
    if (options.gravity) bullet.gravity = options.gravity;
    if (options.spin) bullet.spin = options.spin;
    if (options.color) bullet.color = options.color;
    if (options.explodeDelay) bullet.explodeTime = Date.now() + options.explodeDelay;
    if (options.explodeTime) bullet.explodeTime = options.explodeTime;
    if (options.rotation) bullet.rotation = options.rotation;
    if (options.payload) bullet.payload = options.payload;
  }
  bullets.push(bullet);
  return bullet;
}

function fireBossStraight() {
  const speed = 4 + level * 0.4;
  const bx = boss.x + boss.width / 2 - 2;
  const by = boss.y + boss.height;
  spawnBossBullet(bx, by, 0, speed);
}

function fireBossSpread() {
  const speed = 4 + level * 0.35;
  const baseX = boss.x + boss.width / 2 - 2;
  const by = boss.y + boss.height;
  spawnBossBullet(baseX - 18, by, -1.2, speed);
  spawnBossBullet(baseX, by, 0, speed);
  spawnBossBullet(baseX + 18, by, 1.2, speed);
}

function fireBossWideSpread() {
  const speed = 4 + level * 0.35;
  const baseX = boss.x + boss.width / 2 - 2;
  const by = boss.y + boss.height;
  const offsets = [-2.2, -1.1, 0, 1.1, 2.2];
  for (let o of offsets) {
    spawnBossBullet(baseX + o * 6, by, o, speed);
  }
}

function fireBossAimed() {
  const speed = 4.5 + level * 0.4;
  const bx = boss.x + boss.width / 2 - 2;
  const by = boss.y + boss.height / 2;
  const tx = player.x + player.width / 2;
  const ty = player.y + player.height / 2;
  let dx = tx - bx;
  let dy = ty - by;
  const len = Math.sqrt(dx * dx + dy * dy) || 1;
  dx /= len;
  dy /= len;
  const vx = dx * speed;
  const vy = dy * speed;
  spawnBossBullet(bx, by, vx, vy);
}

function fireBossRain() {
  const speed = 5 + level * 0.3;
  const by = boss.y + boss.height;
  const count = 6;
  const startX = boss.x + 20;
  const endX = boss.x + boss.width - 20;
  for (let i = 0; i < count; i++) {
    const x = startX + ((endX - startX) * i) / (count - 1);
    spawnBossBullet(x, by, 0, speed);
  }
}

function fireBossBarrage() {
  const speed = 4.2 + level * 0.3;
  const by = boss.y + boss.height;
  const count = 8;
  const startX = boss.x + 10;
  const endX = boss.x + boss.width - 10;
  for (let i = 0; i < count; i++) {
    const x = startX + ((endX - startX) * i) / (count - 1);
    const vx = (Math.random() * 2 - 1) * 1.5;
    spawnBossBullet(x, by, vx, speed + Math.random());
  }
}

function fireBossLaserSweep() {
  const speed = 5 + level * 0.35;
  const bottomY = boss.y + boss.height;
  const startX = boss.x + 12;
  const endX = boss.x + boss.width - 12;
  const count = 10;
  const sweepDir = Math.random() < 0.5 ? -1 : 1;
  for (let i = 0; i < count; i++) {
    const t = count === 1 ? 0 : i / (count - 1);
    const x = sweepDir === -1
      ? endX - (endX - startX) * t
      : startX + (endX - startX) * t;
    const vx = sweepDir * (0.6 + t * 1.6);
    spawnBossBullet(x, bottomY, vx, speed);
  }
}

function fireBossPulse() {
  const cx = boss.x + boss.width / 2;
  const cy = boss.y + boss.height / 2;
  const speed = 4.4 + level * 0.3;
  const count = 10;
  const spread = Math.PI * 0.9;
  const startAngle = Math.PI / 2 - spread / 2;
  for (let i = 0; i < count; i++) {
    const angle = startAngle + (spread * i) / (count - 1);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    spawnBossBullet(cx, cy, vx, vy);
  }
}

function createBombardmentTargets() {
  const count = 3 + Math.min(3, Math.floor(level / 2));
  const minX = 80;
  const maxX = WIDTH - 80;
  const targets = [];
  const playerCenter = player.x + player.width / 2;
  targets.push(clamp(playerCenter + (Math.random() * 120 - 60), minX, maxX));
  while (targets.length < count) {
    const t = clamp(minX + Math.random() * (maxX - minX), minX, maxX);
    targets.push(t);
  }
  return targets;
}

function createGrenadeAngles() {
  const base = [-2.4, 0, 2.4];
  return base.map(v => v + (Math.random() - 0.5) * 0.9);
}

function spawnShrapnelBurst(cx, cy, count, speed, color) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    spawnBossBullet(cx - 3, cy - 3, vx, vy, {
      width: 6,
      height: 6,
      type: "shrapnel",
      color: color || "#ffb347",
      spin: 9 * (Math.random() < 0.5 ? -1 : 1)
    });
  }
}

function detonateBomb(bullet) {
  if (!bullet || bullet.dead) return;
  bullet.dead = true;
  const cx = bullet.x + bullet.width / 2;
  const cy = bullet.y + bullet.height / 2;
  spawnExplosion(cx, cy, 26);
  playExplosion();
  const payload = bullet.payload || {};
  const count = payload.count || (10 + Math.floor(level / 2));
  const speed = payload.speed || 3.4;
  const color = payload.color || "#ffb347";
  spawnShrapnelBurst(cx, cy, count, speed, color);
  if (payload.extraRing) {
    spawnShrapnelBurst(cx, cy, payload.extraRing.count || count, payload.extraRing.speed || (speed - 1), payload.extraRing.color || color);
  }
}

function detonateGrenade(bullet) {
  if (!bullet || bullet.dead) return;
  bullet.dead = true;
  const cx = bullet.x + bullet.width / 2;
  const cy = bullet.y + bullet.height / 2;
  spawnExplosion(cx, cy, 20);
  playExplosion();
  const payload = bullet.payload || {};
  const count = payload.count || (8 + Math.floor(level / 3));
  const speed = payload.speed || 4.0;
  const color = payload.color || "#7cffd5";
  spawnShrapnelBurst(cx, cy, count, speed, color);
  if (payload.extraRing) {
    spawnShrapnelBurst(cx, cy, payload.extraRing.count || (count + 4), payload.extraRing.speed || (speed - 1.4), payload.extraRing.color || color);
  }
}

function fireBossBombardment(data) {
  if (!boss || !boss.alive) return;
  const dropY = boss.y + boss.height - 18;
  const targets = data && data.targets && data.targets.length ? data.targets : createBombardmentTargets();
  for (let target of targets) {
    const clampX = clamp(target - 9, boss.x + 8, boss.x + boss.width - 18);
    const vx = (Math.random() - 0.5) * 0.8;
    const vy = 1.6 + Math.random() * 0.6;
    spawnBossBullet(clampX, dropY, vx, vy, {
      width: 18,
      height: 18,
      gravity: 0.18,
      spin: 4 * (Math.random() < 0.5 ? -1 : 1),
      type: "bomb",
      color: "#ffb347",
      payload: {
        count: 10 + Math.floor(level / 2),
        speed: 3.2 + Math.random() * 0.6,
        color: "#ffb347",
        extraRing: { count: 8 + Math.floor(level / 3), speed: 2.2 + Math.random() * 0.4, color: "#ffe29c" }
      }
    });
  }
}

function fireBossGrenadeVolley(data) {
  if (!boss || !boss.alive) return;
  const originX = boss.x + boss.width / 2 - 7;
  const originY = boss.y + boss.height - 16;
  const angles = data && data.angles && data.angles.length ? data.angles : createGrenadeAngles();
  for (let vx of angles) {
    const spinDir = Math.random() < 0.5 ? -1 : 1;
    spawnBossBullet(originX, originY, vx, 1.4 + Math.random() * 0.4, {
      width: 14,
      height: 14,
      gravity: 0.22,
      spin: (4 + Math.random() * 2) * spinDir,
      type: "grenade",
      color: "#7cffd5",
      explodeDelay: 1100 + Math.random() * 400,
      payload: {
        count: 8 + Math.floor(level / 2),
        speed: 4.0 + Math.random() * 0.8,
        color: "#7cffd5",
        extraRing: { count: 10 + Math.floor(level / 3), speed: 2.6 + Math.random() * 0.5, color: "#c8fff1" }
      }
    });
  }
}

function executeBossPattern(pattern, data) {
  if (!boss || !boss.alive) return;
  if (pattern === "straight") fireBossStraight();
  else if (pattern === "spread") fireBossSpread();
  else if (pattern === "wide") fireBossWideSpread();
  else if (pattern === "aimed") fireBossAimed();
  else if (pattern === "rain") fireBossRain();
  else if (pattern === "barrage") fireBossBarrage();
  else if (pattern === "laser") fireBossLaserSweep();
  else if (pattern === "pulse") fireBossPulse();
  else if (pattern === "bombardment") fireBossBombardment(data);
  else if (pattern === "grenade") fireBossGrenadeVolley(data);
}

function bossTryShoot(now) {
  if (!boss || !boss.alive) return;

  // If a telegraph is active, wait until its fire time to shoot
  if (bossTelegraph) {
    if (now >= bossTelegraph.fireTime) {
      executeBossPattern(bossTelegraph.pattern, bossTelegraph.data);
      playBossShoot();
      bossTelegraph = null;

      const hpRatioAfter = boss.hp / boss.maxHp;
      let delayBaseAfter;
      if (hpRatioAfter > 0.66) delayBaseAfter = 900;
      else if (hpRatioAfter > 0.33) delayBaseAfter = 750;
      else delayBaseAfter = 650;
      const delayAfter = Math.max(350, delayBaseAfter - level * 20 + Math.random() * 150);
      nextBossShotTime = now + delayAfter;
    }
    return;
  }

  if (now < nextBossShotTime) return;

  const hpRatio = boss.hp / boss.maxHp;
  let pattern;
  let delayBase;
  let telegraphData = null;
  let telegraphDuration = 450;

  if (hpRatio > 0.66) {
    pattern = "straight";
    delayBase = 900;
  } else if (hpRatio > 0.33) {
    const midRoll = Math.random();
    if (midRoll < 0.3) pattern = "straight";
    else if (midRoll < 0.6) pattern = "spread";
    else if (midRoll < 0.85) pattern = "bombardment";
    else pattern = "laser";
    delayBase = 750;
  } else {
    const roll = Math.random();
    if (roll < 0.15) pattern = "aimed";
    else if (roll < 0.3) pattern = "wide";
    else if (roll < 0.45) pattern = "rain";
    else if (roll < 0.6) pattern = "barrage";
    else if (roll < 0.72) pattern = "bombardment";
    else if (roll < 0.84) pattern = "grenade";
    else if (roll < 0.94) pattern = "laser";
    else pattern = "pulse";
    delayBase = 640;
  }

  if (pattern === "bombardment") {
    telegraphData = { targets: createBombardmentTargets() };
    telegraphDuration = 520;
  } else if (pattern === "grenade") {
    telegraphData = { angles: createGrenadeAngles() };
    telegraphDuration = 500;
  }

  bossTelegraph = {
    pattern: pattern,
    fireTime: now + telegraphDuration,
    data: telegraphData
  };

  // Prevent new telegraphs from scheduling before this one fires
  nextBossShotTime = bossTelegraph.fireTime;
}

// Collisions and game logic
function handleCollisions() {
  // bullets vs enemies / boss / player
  for (let bullet of bullets) {
    if (bullet.fromPlayer) {
      for (let enemy of enemies) {
        if (!enemy.alive) continue;
        if (rectsIntersect(bullet, enemy)) {
          enemy.alive = false;
          bullet.dead = true;
          score += 100;
          spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 16);
          playExplosion();
          dropPowerup(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
          break;
        }
      }
      if (!bullet.dead && boss && boss.alive && rectsIntersect(bullet, boss)) {
        bullet.dead = true;
        boss.hp -= 10;
        score += 50;
        spawnExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2, 24);
        playExplosion();
        if (boss.hp <= 0) {
          boss.alive = false;
          score += 1000;
          dropPowerup(boss.x + boss.width / 2, boss.y + boss.height / 2);
        }
      }
    } else {
      if (rectsIntersect(bullet, player)) {
        if (bullet.type === "bomb") {
          detonateBomb(bullet);
        } else if (bullet.type === "grenade") {
          detonateGrenade(bullet);
        } else {
          bullet.dead = true;
        }
        hitPlayer();
      }
    }
  }
  bullets = bullets.filter(b => !b.dead && b.y > -30 && b.y < HEIGHT + 30 && b.x > -30 && b.x < WIDTH + 30);

  // enemies reaching bottom / player line
  for (let enemy of enemies) {
    if (!enemy.alive) continue;
    if (enemy.y + enemy.height >= HEIGHT - 80) {
      enemy.alive = false;
      hitPlayer();
    }
  }

  // boss reaching bottom line
  if (boss && boss.alive && boss.y + boss.height >= HEIGHT - 80) {
    hitPlayer();
    boss.y = HEIGHT - boss.height - 80;
  }

  // powerups vs player
  for (let p of powerups) {
    if (!p.collected && rectsIntersect(p, player)) {
      p.collected = true;
      applyPowerup(p.type);
    }
  }
  powerups = powerups.filter(p => !p.collected && p.y < HEIGHT + 40);
}

function hitPlayer() {
  if (player.shield) {
    player.shield = false;
    player.shieldUntil = 0;
    playHit();
    return;
  }
  lives -= 1;
  playHit();
  spawnExplosion(player.x + player.width / 2, player.y + player.height / 2, 30);
  if (lives <= 0) {
    endGame();
  } else {
    resetPlayer();
  }
}

function resetPlayer() {
  player.x = WIDTH / 2 - player.width / 2;
  player.y = HEIGHT - 70;
  player.rapid = false;
  player.shield = false;
  player.rapidUntil = 0;
  player.shieldUntil = 0;
}

function endGame() {
  updateHighScore();
  gameState = STATE_GAMEOVER;
  stopMusic();
}

function checkLevelComplete() {
  if (boss && boss.alive) return;
  let anyAlive = false;
  for (let enemy of enemies) {
    if (enemy.alive) {
      anyAlive = true;
      break;
    }
  }
  if (!anyAlive) {
    level += 1;
    startLevel();
  }
}

// Level / wave setup
function startGame() {
  score = 0;
  lives = 3;
  level = 1;
  resetPlayer();
  startLevel();
  gameState = STATE_PLAYING;
  if (musicEnabled && audioInitialized && audioCtx) {
    startMusic();
  }
}

function startLevel() {
  bullets = [];
  enemies = [];
  powerups = [];
  particles = [];
  boss = null;
  bossTelegraph = null;
  enemyDirection = 1;
  enemySpeed = 0.4 + level * 0.1;
  nextBossShotTime = 0;
  nextEnemyShotTime = 0;

  if (level % 3 === 0) {
    createBoss();
  } else {
    createEnemyWave();
  }
}

function createEnemyWave() {
  const rows = Math.min(5, 3 + Math.floor(level / 2));
  const cols = 9;
  const startX = 80;
  const startY = 60;
  const hSpacing = 50;
  const vSpacing = 40;
  enemies = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const styleIndex = (r + c) % ENEMY_STYLES.length;
      enemies.push({
        x: startX + c * hSpacing,
        y: startY + r * vSpacing,
        width: 40,
        height: 30,
        alive: true,
        styleIndex: styleIndex
      });
    }
  }
}

function createBoss() {
  boss = {
    x: WIDTH / 2 - 80,
    y: 80,
    width: 160,
    height: 70,
    hp: 100 + level * 40,
    maxHp: 100 + level * 40,
    vx: 2 + level * 0.2,
    direction: 1,
    alive: true
  };
}

// Drawing helpers
function drawPlayerShip() {
  ctx.save();
  ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
  const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, 25);
  gradient.addColorStop(0, "#00ffff");
  gradient.addColorStop(1, "#0077aa");
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.moveTo(0, -18);
  ctx.lineTo(16, 12);
  ctx.lineTo(-16, 12);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = "#ffffff";
  ctx.beginPath();
  ctx.arc(0, -4, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  if (player.shield) {
    ctx.save();
    ctx.strokeStyle = "rgba(0, 200, 255, 0.8)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 28, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
}

function drawEnemies() {
  ctx.save();
  for (let enemy of enemies) {
    if (!enemy.alive) continue;
    const x = enemy.x;
    const y = enemy.y;
    const w = enemy.width;
    const h = enemy.height;
    const style = ENEMY_STYLES[enemy.styleIndex % ENEMY_STYLES.length] || ENEMY_STYLES[0];
    const gradient = ctx.createLinearGradient(x, y, x, y + h + 10);
    gradient.addColorStop(0, style.bodyStart);
    gradient.addColorStop(1, style.bodyEnd);

    ctx.save();
    ctx.shadowColor = style.bodyEnd + "aa";
    ctx.shadowBlur = 10;
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.moveTo(x + w * 0.5, y - 6);
    ctx.quadraticCurveTo(x + w, y + h * 0.1, x + w, y + h * 0.5);
    ctx.quadraticCurveTo(x + w, y + h, x + w * 0.5, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h * 0.5);
    ctx.quadraticCurveTo(x, y + h * 0.1, x + w * 0.5, y - 6);
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = style.accent;
    ctx.beginPath();
    ctx.moveTo(x + 6, y + h * 0.55);
    ctx.lineTo(x + w - 6, y + h * 0.55);
    ctx.lineTo(x + w - 14, y + h * 0.8);
    ctx.lineTo(x + 14, y + h * 0.8);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = style.eye;
    ctx.beginPath();
    ctx.ellipse(x + w * 0.3, y + h * 0.42, 6, 7, 0, 0, Math.PI * 2);
    ctx.ellipse(x + w * 0.7, y + h * 0.42, 6, 7, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(x + w * 0.27, y + h * 0.38, 2, 0, Math.PI * 2);
    ctx.arc(x + w * 0.67, y + h * 0.38, 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
  ctx.restore();
}

function drawBossTelegraph() {
  if (!boss || !boss.alive || !bossTelegraph) return;
  const pattern = bossTelegraph.pattern;
  const x = boss.x;
  const y = boss.y;
  const w = boss.width;
  const h = boss.height;
  const data = bossTelegraph.data || {};

  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.strokeStyle = "#ffff77";
  ctx.lineWidth = 2;

  if (pattern === "straight") {
    const cx = x + w / 2;
    ctx.beginPath();
    ctx.moveTo(cx, y + h);
    ctx.lineTo(cx, HEIGHT - 40);
    ctx.stroke();
  } else if (pattern === "spread" || pattern === "wide") {
    const cx = x + w / 2;
    const bottomY = y + h;
    const angles = pattern === "spread" ? [-0.4, 0, 0.4] : [-0.7, -0.35, 0, 0.35, 0.7];
    for (let a of angles) {
      ctx.beginPath();
      ctx.moveTo(cx, bottomY);
      const endX = cx + Math.tan(a) * (HEIGHT - bottomY - 40);
      ctx.lineTo(endX, HEIGHT - 40);
      ctx.stroke();
    }
  } else if (pattern === "aimed") {
    const cx = x + w / 2;
    const cy = y + h / 2;
    const tx = player.x + player.width / 2;
    const ty = player.y + player.height / 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(tx, ty);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(tx, ty, 10, 0, Math.PI * 2);
    ctx.stroke();
  } else if (pattern === "rain") {
    const startX = x + 20;
    const endX = x + w - 20;
    const count = 6;
    const bottomY = y + h;
    for (let i = 0; i < count; i++) {
      const lx = startX + ((endX - startX) * i) / (count - 1);
      ctx.beginPath();
      ctx.moveTo(lx, bottomY);
      ctx.lineTo(lx, HEIGHT - 40);
      ctx.stroke();
    }
  } else if (pattern === "barrage") {
    const startX = x + 10;
    const endX = x + w - 10;
    const bottomY = y + h;
    const count = 8;
    for (let i = 0; i < count; i++) {
      const lx = startX + ((endX - startX) * i) / (count - 1);
      ctx.beginPath();
      ctx.moveTo(lx, bottomY);
      ctx.lineTo(lx + (Math.random() * 60 - 30), HEIGHT - 40);
      ctx.stroke();
    }
  } else if (pattern === "laser") {
    const bottomY = y + h;
    const startX = x + 12;
    const endX = x + w - 12;
    const count = 5;
    for (let i = 0; i < count; i++) {
      const t = count === 1 ? 0 : i / (count - 1);
      const lx = startX + (endX - startX) * t;
      ctx.beginPath();
      ctx.moveTo(lx, bottomY);
      ctx.lineTo(lx + (t - 0.5) * 160, HEIGHT - 40);
      ctx.stroke();
    }
  } else if (pattern === "pulse") {
    const cx = x + w / 2;
    const cy = y + h / 2;
    const count = 8;
    const spread = Math.PI * 0.9;
    const startAngle = Math.PI / 2 - spread / 2;
    for (let i = 0; i < count; i++) {
      const angle = startAngle + (spread * i) / (count - 1);
      const length = 180;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(angle) * length, cy + Math.sin(angle) * length);
      ctx.stroke();
    }
  } else if (pattern === "bombardment") {
    const bottomY = HEIGHT - 70;
    const targets = data.targets || [];
    ctx.setLineDash([8, 6]);
    for (let target of targets) {
      const cx = clamp(target, 40, WIDTH - 40);
      ctx.beginPath();
      ctx.moveTo(cx, y + h);
      ctx.lineTo(cx, bottomY - 20);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(cx, bottomY - 10, 22, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  } else if (pattern === "grenade") {
    const originX = x + w / 2;
    const originY = y + h - 6;
    const angles = data.angles || [-2.2, 0, 2.2];
    ctx.setLineDash([6, 5]);
    for (let vx of angles) {
      const midX = originX + vx * 40;
      const midY = originY + 60;
      const endX = clamp(originX + vx * 85, 40, WIDTH - 40);
      const endY = originY + 150;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.quadraticCurveTo(midX, midY, endX, endY);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(endX, endY, 20, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.setLineDash([]);
  }

  ctx.restore();
}

function drawBoss() {
  if (!boss || !boss.alive) return;
  const x = boss.x;
  const y = boss.y;
  const w = boss.width;
  const h = boss.height;

  ctx.save();
  ctx.shadowColor = "rgba(255, 120, 40, 0.6)";
  ctx.shadowBlur = 25;
  const hullGradient = ctx.createLinearGradient(x, y, x, y + h);
  hullGradient.addColorStop(0, "#ffb677");
  hullGradient.addColorStop(0.4, "#ff6b3d");
  hullGradient.addColorStop(1, "#c4120f");
  ctx.fillStyle = hullGradient;
  ctx.beginPath();
  ctx.moveTo(x + w * 0.15, y + h * 0.22);
  ctx.quadraticCurveTo(x + w * 0.5, y - 60, x + w * 0.85, y + h * 0.22);
  ctx.quadraticCurveTo(x + w * 1.08, y + h * 0.62, x + w * 0.82, y + h * 0.98);
  ctx.lineTo(x + w * 0.18, y + h * 0.98);
  ctx.quadraticCurveTo(x - w * 0.08, y + h * 0.62, x + w * 0.15, y + h * 0.22);
  ctx.closePath();
  ctx.fill();

  ctx.shadowBlur = 0;
  const wingGradient = ctx.createLinearGradient(x, y + h * 0.35, x, y + h);
  wingGradient.addColorStop(0, "#86240a");
  wingGradient.addColorStop(1, "#ff7c3a");
  ctx.fillStyle = wingGradient;
  ctx.beginPath();
  ctx.moveTo(x - 30, y + h * 0.45);
  ctx.quadraticCurveTo(x + w * 0.08, y + h * 0.55, x + w * 0.16, y + h);
  ctx.lineTo(x + w * 0.02, y + h);
  ctx.quadraticCurveTo(x - 34, y + h * 0.7, x - 30, y + h * 0.45);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x + w + 30, y + h * 0.45);
  ctx.quadraticCurveTo(x + w * 0.92, y + h * 0.55, x + w * 0.84, y + h);
  ctx.lineTo(x + w * 0.98, y + h);
  ctx.quadraticCurveTo(x + w + 34, y + h * 0.7, x + w + 30, y + h * 0.45);
  ctx.closePath();
  ctx.fill();

  const canopyGradient = ctx.createLinearGradient(x + w * 0.3, y + h * 0.25, x + w * 0.7, y + h * 0.7);
  canopyGradient.addColorStop(0, "rgba(255,255,255,0.7)");
  canopyGradient.addColorStop(0.5, "rgba(180,220,255,0.5)");
  canopyGradient.addColorStop(1, "rgba(40,80,180,0.4)");
  ctx.fillStyle = canopyGradient;
  ctx.beginPath();
  ctx.ellipse(x + w / 2, y + h * 0.45, w * 0.2, h * 0.28, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#1a0300";
  ctx.beginPath();
  ctx.ellipse(x + w * 0.35, y + h * 0.45, 12, 16, 0, 0, Math.PI * 2);
  ctx.ellipse(x + w * 0.65, y + h * 0.45, 12, 16, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#fffbf0";
  ctx.beginPath();
  ctx.arc(x + w * 0.32, y + h * 0.4, 4, 0, Math.PI * 2);
  ctx.arc(x + w * 0.62, y + h * 0.4, 4, 0, Math.PI * 2);
  ctx.fill();

  const coreX = x + w / 2;
  const coreY = y + h * 0.68;
  const coreGradient = ctx.createRadialGradient(coreX, coreY, 6, coreX, coreY, 32);
  coreGradient.addColorStop(0, "rgba(255,255,255,0.95)");
  coreGradient.addColorStop(0.3, "#ffe06b");
  coreGradient.addColorStop(0.7, "#ff4f26");
  coreGradient.addColorStop(1, "rgba(120,0,0,0.8)");
  ctx.fillStyle = coreGradient;
  ctx.beginPath();
  ctx.ellipse(coreX, coreY, 28, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.ellipse(coreX, coreY, 28, 30, 0, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = "#ffdf9b";
  ctx.beginPath();
  ctx.moveTo(x + w * 0.25, y + h * 0.82);
  ctx.lineTo(x + w * 0.75, y + h * 0.82);
  ctx.lineTo(x + w * 0.68, y + h * 0.92);
  ctx.lineTo(x + w * 0.32, y + h * 0.92);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle = "#311000";
  ctx.fillRect(x + w * 0.25, y + h - 16, w * 0.5, 8);
  ctx.fillStyle = "#ffb347";
  ctx.fillRect(x + w * 0.28, y + h - 14, w * 0.44, 4);

  const hpRatio = boss.hp / boss.maxHp;
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fillRect(x, y - 16, w, 8);
  const hpGradient = ctx.createLinearGradient(x, y - 16, x + w, y - 16);
  hpGradient.addColorStop(0, "#ff3b3b");
  hpGradient.addColorStop(1, "#ffd166");
  ctx.fillStyle = hpGradient;
  ctx.fillRect(x, y - 16, w * hpRatio, 8);
  ctx.strokeStyle = "rgba(255,120,0,0.7)";
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y - 16, w, 8);

  ctx.restore();

  drawBossTelegraph();
}

function drawBullets() {
  for (let b of bullets) {
    if (b.fromPlayer) {
      ctx.fillStyle = "#00f7ff";
      ctx.fillRect(b.x, b.y, b.width, b.height);
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
      ctx.fillRect(b.x + 1, b.y, b.width - 2, b.height / 2);
    } else if (b.type === "bomb") {
      const cx = b.x + b.width / 2;
      const cy = b.y + b.height / 2;
      const radius = Math.max(b.width, b.height) / 2;
      const grad = ctx.createRadialGradient(cx, cy, radius * 0.2, cx, cy, radius);
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.5, b.color || "#ffb347");
      grad.addColorStop(1, "#4a1b00");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "rgba(255, 200, 120, 0.5)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, radius + 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (b.type === "grenade") {
      const cx = b.x + b.width / 2;
      const cy = b.y + b.height / 2;
      const radius = Math.max(b.width, b.height) / 2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate((b.rotation || 0) * Math.PI / 180);
      const grad = ctx.createRadialGradient(0, 0, radius * 0.2, 0, 0, radius);
      grad.addColorStop(0, "#eaffff");
      grad.addColorStop(0.6, b.color || "#7cffd5");
      grad.addColorStop(1, "#024b37");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, -radius);
      ctx.quadraticCurveTo(radius, -radius * 0.6, radius, 0);
      ctx.quadraticCurveTo(radius, radius * 0.6, 0, radius);
      ctx.quadraticCurveTo(-radius, radius * 0.6, -radius, 0);
      ctx.quadraticCurveTo(-radius, -radius * 0.6, 0, -radius);
      ctx.fill();
      ctx.restore();
      ctx.strokeStyle = "rgba(120, 255, 200, 0.4)";
      ctx.beginPath();
      ctx.arc(cx, cy, radius + 4, 0, Math.PI * 2);
      ctx.stroke();
    } else if (b.type === "shrapnel") {
      const cx = b.x + b.width / 2;
      const cy = b.y + b.height / 2;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate((b.rotation || 0) * Math.PI / 180);
      ctx.fillStyle = b.color || "#ffb347";
      ctx.beginPath();
      ctx.moveTo(0, -3);
      ctx.lineTo(3, 0);
      ctx.lineTo(0, 3);
      ctx.lineTo(-3, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    } else {
      ctx.fillStyle = b.color || "#ff3333";
      ctx.fillRect(b.x, b.y, b.width, b.height);
      ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
      ctx.fillRect(b.x + 1, b.y + 1, b.width - 2, 2);
    }
  }
}

function drawPowerups() {
  for (let p of powerups) {
    let color = "#ffff00";
    let label = "P";
    if (p.type === "shield") { color = "#00ffff"; label = "S"; }
    else if (p.type === "rapid") { color = "#ff66ff"; label = "R"; }
    else if (p.type === "nuke") { color = "#ff0000"; label = "N"; }
    else if (p.type === "life") { color = "#00ff00"; label = "+"; }
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(p.x + p.width / 2, p.y + p.height / 2, p.width / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "#000000";
    ctx.font = "12px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, p.x + p.width / 2, p.y + p.height / 2);
    ctx.restore();
  }
}

function drawHUD() {
  ctx.save();
  ctx.fillStyle = "#6df";
  ctx.font = "18px Arial";
  ctx.textAlign = "left";
  ctx.fillText("Score: " + score, 10, 24);
  ctx.fillText("Lives: " + lives, 10, 46);
  ctx.textAlign = "right";
  ctx.fillText("Level: " + level, WIDTH - 10, 24);
  ctx.fillText("High: " + highScore, WIDTH - 10, 46);
  ctx.restore();
}

function drawMenu() {
  ctx.save();
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 40px Arial";
  ctx.textAlign = "center";
  ctx.fillText("SPACE INVADERS ULTRA", WIDTH / 2, HEIGHT / 2 - 80);
  ctx.font = "20px Arial";
  ctx.fillStyle = "#6df";
  ctx.fillText("High Score: " + highScore, WIDTH / 2, HEIGHT / 2 - 40);
  ctx.fillStyle = "#ffffff";
  ctx.fillText("Press ENTER or TAP to start", WIDTH / 2, HEIGHT / 2 + 10);
  ctx.fillText("Move: ← → or A/D   Shoot: SPACE", WIDTH / 2, HEIGHT / 2 + 40);
  ctx.fillText("Press S for Settings", WIDTH / 2, HEIGHT / 2 + 70);
  ctx.restore();
}

function drawSettings() {
  ctx.save();
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 36px Arial";
  ctx.textAlign = "center";
  ctx.fillText("SETTINGS", WIDTH / 2, HEIGHT / 2 - 60);
  ctx.font = "20px Arial";
  ctx.fillText("M - Music: " + (musicEnabled ? "ON" : "OFF"), WIDTH / 2, HEIGHT / 2 - 10);
  ctx.fillText("V - Sound Effects: " + (sfxEnabled ? "ON" : "OFF"), WIDTH / 2, HEIGHT / 2 + 20);
  ctx.fillText("Press S or ESC to return", WIDTH / 2, HEIGHT / 2 + 60);
  ctx.restore();
}

function drawPauseOverlay() {
  ctx.save();
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 32px Arial";
  ctx.textAlign = "center";
  ctx.fillText("PAUSED", WIDTH / 2, HEIGHT / 2);
  ctx.font = "20px Arial";
  ctx.fillText("Press P or ESC to resume", WIDTH / 2, HEIGHT / 2 + 40);
  ctx.restore();
}

function drawGameOverOverlay() {
  ctx.save();
  ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  ctx.fillStyle = "#ff5555";
  ctx.font = "bold 36px Arial";
  ctx.textAlign = "center";
  ctx.fillText("GAME OVER", WIDTH / 2, HEIGHT / 2 - 20);
  ctx.fillStyle = "#ffffff";
  ctx.font = "20px Arial";
  ctx.fillText("Score: " + score + "   High: " + highScore, WIDTH / 2, HEIGHT / 2 + 15);
  ctx.fillText("Press ENTER or TAP to return to menu", WIDTH / 2, HEIGHT / 2 + 50);
  ctx.restore();
}

function drawRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

function drawTouchControls() {
  ctx.save();
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = "#ffffff";
  drawRoundedRect(touchControls.left.x, touchControls.left.y, touchControls.left.width, touchControls.left.height, 8);
  drawRoundedRect(touchControls.right.x, touchControls.right.y, touchControls.right.width, touchControls.right.height, 8);
  drawRoundedRect(touchControls.shoot.x, touchControls.shoot.y, touchControls.shoot.width, touchControls.shoot.height, 8);
  ctx.globalAlpha = 0.6;
  ctx.font = "18px Arial";
  ctx.textAlign = "left";
  ctx.fillText("<", touchControls.left.x + 30, touchControls.left.y + 38);
  ctx.fillText(">", touchControls.right.x + 30, touchControls.right.y + 38);
  ctx.fillText("FIRE", touchControls.shoot.x + 18, touchControls.shoot.y + 38);
  ctx.restore();
}

// Game loop
function update() {
  updateStars();
  if (gameState === STATE_PLAYING) {
    updatePlaying();
  }
}

function updatePlaying() {
  const now = Date.now();

  if (player.rapid && now > player.rapidUntil) {
    player.rapid = false;
  }
  if (player.shield && now > player.shieldUntil) {
    player.shield = false;
  }

  movePlayer();
  moveBullets();
  moveEnemies();
  moveBoss();
  movePowerups();
  updateParticles();

  if (input.shoot) {
    tryShoot(now);
  }
  enemyTryShoot(now);
  if (boss && boss.alive) {
    bossTryShoot(now);
  }

  handleCollisions();
  checkLevelComplete();
}

function render() {
  ctx.clearRect(0, 0, WIDTH, HEIGHT);
  drawStars();

  if (gameState === STATE_MENU) {
    drawMenu();
  } else if (gameState === STATE_SETTINGS) {
    drawSettings();
  } else {
    drawPlayerShip();
    drawEnemies();
    drawBoss();
    drawBullets();
    drawPowerups();
    drawParticles();
    drawHUD();

    if (gameState === STATE_PAUSED) {
      drawPauseOverlay();
    }
    if (gameState === STATE_GAMEOVER) {
      drawGameOverOverlay();
    }
  }

  drawTouchControls();
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

// Input handling
function handleEnter() {
  if (gameState === STATE_MENU || gameState === STATE_GAMEOVER) {
    startGame();
  } else if (gameState === STATE_SETTINGS) {
    gameState = STATE_MENU;
  }
}

function togglePause() {
  if (gameState === STATE_PLAYING) {
    gameState = STATE_PAUSED;
    stopMusic();
  } else if (gameState === STATE_PAUSED) {
    gameState = STATE_PLAYING;
    if (musicEnabled && audioInitialized && audioCtx) {
      startMusic();
    }
  }
}

function toggleSettings() {
  if (gameState === STATE_MENU) {
    gameState = STATE_SETTINGS;
  } else if (gameState === STATE_SETTINGS) {
    gameState = STATE_MENU;
  }
}

document.addEventListener("keydown", function(e) {
  if (e.code === "ArrowLeft" || e.code === "KeyA") {
    input.left = true;
  } else if (e.code === "ArrowRight" || e.code === "KeyD") {
    input.right = true;
  } else if (e.code === "Space") {
    input.shoot = true;
  } else if (e.code === "Enter") {
    handleEnter();
  } else if (e.code === "KeyP" || e.code === "Escape") {
    togglePause();
  } else if (e.code === "KeyS") {
    toggleSettings();
  } else if (e.code === "KeyM") {
    toggleMusic();
  } else if (e.code === "KeyV") {
    toggleSfx();
  }
  handleFirstInteraction();
});

document.addEventListener("keyup", function(e) {
  if (e.code === "ArrowLeft" || e.code === "KeyA") {
    input.left = false;
  } else if (e.code === "ArrowRight" || e.code === "KeyD") {
    input.right = false;
  } else if (e.code === "Space") {
    input.shoot = false;
  }
});

canvas.addEventListener("pointerdown", function(e) {
  const pos = getPointerPos(e);
  handleFirstInteraction();

  if (gameState === STATE_MENU || gameState === STATE_GAMEOVER) {
    startGame();
  } else if (gameState === STATE_SETTINGS) {
    gameState = STATE_MENU;
  }

  if (pointInRect(pos, touchControls.left)) {
    input.left = true;
  }
  if (pointInRect(pos, touchControls.right)) {
    input.right = true;
  }
  if (pointInRect(pos, touchControls.shoot)) {
    input.shoot = true;
  }
});

canvas.addEventListener("pointerup", function() {
  input.left = false;
  input.right = false;
  input.shoot = false;
});

canvas.addEventListener("pointercancel", function() {
  input.left = false;
  input.right = false;
  input.shoot = false;
});

canvas.addEventListener("pointerleave", function() {
  input.left = false;
  input.right = false;
  input.shoot = false;
});

// Start
initStars();
loadHighScore();
requestAnimationFrame(loop);
</script>
</body>
</html>
